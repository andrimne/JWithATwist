(*
    JWithATwist - A Twisted Version of the Programming Language J
    Copyright (C) 2016 Erling Hellenäs

    This program is free software: you can redistribute it and/or modify
    it under the terms of the GNU General Public License as published by
    the Free Software Foundation, either version 3 of the License, or
    (at your option) any later version.

    This program is distributed in the hope that it will be useful,
    but WITHOUT ANY WARRANTY; without even the implied warranty of
    MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE.  See the
    GNU General Public License for more details.

    You should have received a copy of the GNU General Public License
    along with this program.  If not, see <http://www.gnu.org/licenses/>.
*)

// Learn more about F# at http://fsharp.org
// See the 'F# Tutorial' project for more help.
open JWithATwist
open JWithATwist.Base
open JWithATwist.Define
//(*
open JWithATwist.ParserDefinitions
open JWithATwist.ParserInterface
open JWithATwist.Parser
//*)
(*
open J4Mono.ParserMockDefinitions
open J4Mono.ParserMockInterface
open J4Mono.ParserMock
*)
open System
open System.Text
open System.IO
open System.Diagnostics
open FParsec
open Operators.Checked

let baseEncode baseArray number =
    let a = 
        Array.scanBack 
            (
                fun dimBase (quo,rem)  -> 
                    (quo/dimBase,quo % dimBase)
            )  
            baseArray  
            (number,0)
    let b = Array.map (fun (quo,rem) -> rem) a
    Array.sub b 0 (b.Length-1)

    //let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    //stopWatch.Stop()
    //printfn "%f" stopWatch.Elapsed.TotalMilliseconds

   
let genRandomNumbers count =
    let rnd = System.Random()
    seq {for i = 0 to count do yield (rnd.Next ())}


 (*
    let rnd = System.Random()
    let count = 10
    let a:int [] = Array.zeroCreate count
    let i = ref 0
    let seti value a i =
        Array.set a !i (rnd.Next())
        i := !i + 1
        ()
    let k value = seti value a i
    k 1
    k 2
 *)

 (*
 //For each number in the sequence generated by i., where should I put it in the array?
   a=:(|3 _3) #:1
   q =: 3 _3 <0
   r=:((-.q)*a)+(q*|3 _3+q)-q*a
   r
0 1
   3 3#. r
1
//For each array element, what should I put there?
//For each array index, what element should be delivered if there is no array?
   b=:_3 3
   b1=:|b
   b2=:<:b1
   c=:}.|.*/\1,|.b1
   q=:b < 0
   a=:8
   a3=:b1#:a
   +/(q*c*b2-a3)+(-.q)*a3
2
 *)


 
let test p str =
    match run p str with
    | Success(result, _, rest)   -> printfn "Success: %A %A" result rest
    | Failure(errorMsg, n, m) -> printfn "Failure: %s %A %A" errorMsg n m

type a = 
    {
        a:string
        b:int
    }


[<EntryPoint>]
let main argv = 

    //let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    //stopWatch.Stop()
    //printfn "%f" stopWatch.Elapsed.TotalMilliseconds
(*
            
    let resultOption = parseAllSpeach @"
{ 
   100 <.-  
   ( 40000 $ 0 0 0 1 0 0 1 0 0 1 0 0 1 0   0 0 1 0 0 0 0 0 0 1 0 0 0 1   0 0 0 1 0 0 0 0 0 0 0 0 0 1   0 0 0 1 0 0 1 0 0 0 1 0 0 1 ) 
   {! 
        |> 
        ( |< |i. 0 ) {! |< ( |> [ ) , |> ] } /  
        ( 
            {! 
                ( |< |, -1 ) {! |< ( 1 + ( |i. 0 ) $ -1 <.- |> [ ) + |i. ] } \ ] 
            } 
            {! 
                ] - 0 , -1 >.- ] 
            } 
            {! 
                ( 1 = ] ) /:: |i. |# ] 
            }  
            [ , 1 
        ) 
        {! 
            |< 
            {! 
                ( |i. |- |# ] ) <- ] 
            } 
            {! 
               ( |_ 1 = 0 + \  ] ) * ] 
            } 
            {! 
                ( |i. |- |# ] ) <- ] 
            } 
            (  |>  [ ) <- ] 
        } '/ 0 1 / ] 
    } 
    ( 40000 $ 0 0 1 0 0 1 0 0 1 0 1 0 0 1   0 1 0 1 0 1 0 1 0 0 1 0 0 0   1 0 0 0 1 0 0 0 0 0 0 0 0 0   1 0 0 0 1 0 0 1 0 0 0 1 0 0 ) 
} "
    match resultOption with
        | Success(result, _, rest)   -> 
            match result with
            |[parseResult] ->
                match parseResult with
                |{Value=TypeNounUnit f} ->
                    let stopWatch = System.Diagnostics.Stopwatch.StartNew()
                    printfn "%A" (f ())
                    stopWatch.Stop()
                    printfn "%f" stopWatch.Elapsed.TotalMilliseconds

                |_ ->
                    printfn "Error"
            |_ ->
                printfn "Error" 
        |_ -> 
            printfn "Error" 
            *)

    //let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    //stopWatch.Stop()
    //printfn "%f" stopWatch.Elapsed.TotalMilliseconds
    


    Parser()
    (*
    let resultOption = parseAllSpeach @"{!  2147483647 * 2 } "
    match resultOption with
        | Success(result, _, rest)   -> 
            match result with
            |[parseResult] ->
                match parseResult with
                |{Value=TypeNounUnit f} ->
                    let a = new StringWriter()
                    Console.SetOut(a)
                    ParsePrint parseResult
                    let expected = "Overflow"
                    let actual = a.ToString()
                    printfn "%A %A" actual expected
                |_ ->
                    ()
            |_ ->
                ()
        |_ -> 
            ()
            *)

    (*
    let count = 10000000
    let index = Seq.init count id
    let array = Seq.toArray (genRandomNumbers count)

    let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    let sorted = GradeUp array
    stopWatch.Stop()
    printfn "GradeUp: %f" stopWatch.Elapsed.TotalMilliseconds

    let stopWatch = System.Diagnostics.Stopwatch.StartNew()
    let sorted = Array.sort array
    stopWatch.Stop()
    printfn "Array.sort: %f" stopWatch.Elapsed.TotalMilliseconds
    

    *)

    //Console.ReadLine() |> ignore
    
    0 // return an integer exit code